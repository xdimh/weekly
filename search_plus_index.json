{"./":{"url":"./","title":"前言","keywords":"","body":"关于本书 前端是一个技术更新发展比较快的行业,需要你不停的去学习,更新完善自己的技术栈,俗话说,好记性不如烂笔头,打算把自己做项目过程中的一些心得,遇到过并填过的坑,同时将自己学习的新知识,平常摸过的鱼记录在此,以便以后如果遇到类似的问题,类似的坑,需要用到之前看过的技术的时候有个地方可以参考。 不管做什么贵在坚持,希望自己能够坚持做好记录这件事。 var className='atoc'; © xdimh all right reserved，powered by Gitbook该文件修订时间： 2017-02-11 20:16:12 "},"react/react-life-cycle.html":{"url":"react/react-life-cycle.html","title":"React 生命周期","keywords":"","body":"React 的生命周期 对于React的生命周期,只要知道在整个生命周期里,有的生命周期函数只调用一次,有的在每次数据更新的时候会被反复调用。如下图: Image 1.2.1.1 - react-life-cycle React 生命周期的三个阶段 1. 组件初始化 初始化阶段执行的生命周期函数(除了render)在整个生命周期中只会被执行一次。 getDefaultProps 设置组件的初始属性,ES6写法和这里的ES5写法有所区别: static defaultProps = { defaultTxt : 'AA' }; getInitialState 设置组件的初始状态,ES6写法和这里的ES5写法有所区别,是在ES6类的构造器中进行初始化: constructor(props) { super(props); this.state = { state1 : 'xxx' }; } componentWillMount 组件即将被挂载前执行的生命周期函数,在这个函数里是组件挂载之前修改组件状态的最后机会。这个函数只会在第一次初始化的时候才会被执行到,后续组件存在期,组件状态的变更将不再被执行。 render 将React Elements 渲染进DOM,整个生命周期被执行最多的函数,渲染的时候采用的是最小化增量更新,所以理论上React 会有不错的性能。 componentDidMount React 组件以及成功挂载到DOM中的hooks函数。在这个函数内可以对组件进行DOM操作,在初始化阶段,只有在这个方法内才能够通过this.refs.elementId读取到组件的DOM节点。 2. 组件存在期 组件的存在期,应该是整个生命周期中最长的一个阶段,也是组件响应用户的行为的一个阶段。 componentWillReceiveProps(nextProps) 组件在存在期接受的父组件提供的属性发生变化,或者调用了setProps修改组件属性的时候将会被调用,开始一个组件更新的cycle。 shouldComponentUpdate(nextProps,nextState) 这个生命周期方法只会在存在期阶段被调用,当组件的属性发生变化(父组件下发的属性改变,setProps被调用),组件的状态发生改变(setState被调用)该方法就会在一个cycle中被执行到且只有当该方法返回true,cycle中后续的函数才有机会被执行,不然后续函数将不会被执行,所以这个函数常常作为React性能优化的地方,省去不必要的渲染更新。 componentWillUpdate(nextProps,nextState) 组件更新之前会被执行的函数。 render 同初始阶段,但在componentWillUpdate之后componentDidUpdate之前执行。 componentDidUpdate(prevProps,prevState) 组件成功更新后的hooks函数。当组件更新完成会被调用。 3. 组件销毁&清理 当切换页面,或者切换组件的时候,组件就会被销毁,这个时候,往往需要对组件进行一些清理操作,释放一些资源。 componentWillUnmount 这个方法用来在组件销毁前做一些清理,释放占用资源,解除事件绑定等操作。整个生命周期会被执行一次。 var className='atoc'; © xdimh all right reserved，powered by Gitbook该文件修订时间： 2017-03-05 20:58:55 "},"react-native/rn-dev-prepare.html":{"url":"react-native/rn-dev-prepare.html","title":"Mac上搭建RN开发环境","keywords":"","body":"Mac上搭建RN开发环境 安装依赖 在针对特定平台开发环境建立之前,你需要先安装node,watchman,react-native-cli。在Mac上我们可以通过HomeBrew进行相应的安装。 brew install node brew install watchman brew install flow npm install -g react-native-cli ios 开发环境搭建 对于ios 只需要从app store中安装xcode即可,安装xcode会自动安装ios 模拟器以及一些构建app所需要的工具。通过react-native 命令初始化一个项目然后测试ios开发环境是否成功建立。 react-native init AwesomeProject cd AwesomeProject 在ios模拟器中启动应用,两种方式: 通过命令行直接唤起模拟器打开app react-native run-ios 执行完该命令,正常情况下,会打开ios模拟器,然后启动应用以供调试。 进入目录AwesomeProject,打开ios目录下的文件AwesomeProject.xcodeproj,如果xcode成功安装,默认会打开xcode。然后直接 android 开发环境搭建 对于android开发环境要稍微复杂一些。 安装安卓模拟器genymotion 安装完成后需要去官网注册一个账户并激活,后续创建虚拟设备将会用到。 安装virtual box 安装最新版JDK 安装安卓Android Studio 打开sdk manager 安装的Android sdk Image 1.3.1.1 - android studio 选择需要安装的内容 Image 1.3.1.2 - android sdk 打开genymotion 创建安卓模拟器 先设置好正确的android sdk路径 添加相应的虚拟设备 打开对应的虚拟设备测试安卓开发环境是否成功建立 打开对于的虚拟设备后,在项目根目录执行命令启动应用: react-native run-android 这一步可能发送报错java.io.EOFException: SSL peer shut down incorrectly,解决方案在后面。 这个时候如果build successfully 则在模拟器上可以看到对于app的页面,如果模拟器上出现如下报错: 需要设置对应的debug host为当前电脑的ip地址,如下图: 环境配置过程报错解决 对于安卓开发环境步骤6中运行react-native run-android所报错误解决方法 下载gradle-2.4-all.zip到本地 本地启动对于的服务 修改android/gradle/wrapper下gradle-wrapper.properties文件中的distributionUrl为本地地址,重新执行react-native run-android 参考资料 React Native Android（Genymotion） 环境搭建 for mac 学习 React Native for Android：环境搭建 Getting Started with Building An App with React Native, Genymotion, and Watchman react native getting started react-native run-android 报错解决 React Native For Android初体验 var className='atoc'; © xdimh all right reserved，powered by Gitbook该文件修订时间： 2017-02-14 13:59:35 "},"electron/":{"url":"electron/","title":"Electron 开发汇总","keywords":"","body":"var className='atoc'; © xdimh all right reserved，powered by Gitbook该文件修订时间： 2017-02-08 14:48:57 "},"node/node-stream.html":{"url":"node/node-stream.html","title":"Node Stream 初窥","keywords":"","body":"Node Stream 初窥 Node 将几乎所有 IO 操作都抽象成了 Stream 的操作。Stream 是一个抽象的概念，可以将Stream 想象成水流管道,管道有只用于输出的,有只接收的,有负责中间过渡的(既有输入的一端,也有输出的一端)。总之就是生产东西,或者消费东西,这个东西可以是Buffer,可以是String,甚至是可以Object。从Node 官方文档对Stream的定义, A stream is an abstract interface implemented by various objects in Node. For example a request to an HTTP server is a stream, as is stdout. Streams are readable, writable, or both. All streams are instances of EventEmitter 我们可以了解到 : Stream是Node中一个非常重要的概念，被大量对象实现，尤其是Node中的I/O操作 Stream是一个抽像的接口，一般不会直接使用，需要实现内部的某些抽象方法(例如_read、_write、_transform) Stream是EventEmitter的子类，实际上Stream的数据传递内部依然是通过事件(data)来实现的 那为什么会需要流。看下面这段代码: var http = require('http'); var fs = require('fs'); var server = http.createServer(function (req, res) { // req is an http.IncomingMessage, which is a Readable Stream // res is an http.ServerResponse, which is a Writable Stream fs.readFile(__dirname + '/data.txt', function (err, data) { res.end(data); }); }); server.listen(8000); 每次当请求过来,程序都会接收到这个请求,然后去读data.txt文件,并把内容返回。但是每次读的时候都会把data.txt整个读入内存,在响应大量用户的并发请求时，程序可能会消耗大量的内存，这样很可能会造成用户连接缓慢的问题。其次，上面的代码可能会造成很不好的用户体验，因为用户在接收到任何的内容之前首先需要等待程序将文件内容完全读入到内存中。所以更好的办法就是需要多少给多少,而不是一股脑的将整个数据放到内存中,通过流可以实现这一的效果。 var http = require('http'); var fs = require('fs'); var server = http.createServer(function (req, res) { // req is an http.IncomingMessage, which is a Readable Stream // res is an http.ServerResponse, which is a Writable Stream var stream = fs.createReadStream(__dirname + '/data.txt'); stream.pipe(res); }); server.listen(8000); Node 中Stream的类型 在Node.js中,有四种基本的流类型,他们分别是:Readable ,Writable,Duplex,Transform。流一般处理的数据类型都是String 和 Buffer的,但是你可以通过在创建流的时候指定选项参数objectMode,创建对象流,不过需要注意的是,尝试将已存在的流的模式切换成对象流是一种不安全的不被建议的操作。 不管是Readable 还是 Writable 流,工作的过程都会将数据保存在内部的一个缓冲区中,可以分别通过readable._readableState.buffer , writable._writableState.getBuffer() 取出buffer内容。我们可以通过选项参数highWaterMark控制缓冲区的大小,对于String 或者 Buffer流来说,highWaterMark 控制的字节数,对于对象流,highWaterMark控制的是对象的个数。 1. Readable 可读流,是输出流,通过readable.push(chunk)将数据读入流的缓冲区以供读取,消费者可以通过readable.read()读取流中的数据,如果缓冲区中的数据一直没有被消费掉,一旦到达 highWaterMark 设置的阈值,那么输出流就会停止往缓冲区中放数据,知道有消费者消耗掉这些数据。 Once the total size of the internal read buffer reaches the threshold specified by highWaterMark, the stream will temporarily stop reading data from the underlying resource until the data currently buffered can be consumed (that is, the stream will stop calling the internal readable._read() method that is used to fill the read buffer). Readable 有两种模式,分别是 flowing 和 paused 模式。flowing 模式,会自动的从源读取数据通过事件的方式提供给应用消费,而paused 模式需要显示手动调用readable.read()方法,从流中读取数据。所有的Readable流一开始都是paused模式,但是可以通过下面的几种方法切换成flowing 模式: 添加data事件处理器。 调用 readable.resume() 方法。 调用 readable.pipe() 方法发送数据到Writeable 流。 只要监听了data事件或者是调用readable.resume(),readable.pipe()方法,都会将readable._readableState.flowing 设置为true。使得Readable当数据生成时不断的触发data事件。流程图大致如下: Image 1.5.1.1 - Readable 流程 同样可以通过一些方式将模式从 flowing 切换回 paused。 具体方法参考官方文档。 2. Writable 可写流,输入流,是对数据写入目标的一个抽象,将内容通过writable.write(chunk)存入流缓冲区中,如果没有超出限制,则返回true,如果超出限制,则返回false。 实现自己的Writable 继承Writable ,重写方法_write,_writev,任何的可写流都必须提供方法_write,用于将数据写入底层资源(如某个文件)。实现自己的Writable代码如下: //写法1: const Writable = require('stream').Writable; class MyWritable extends Writable { constructor(options) { // Calls the stream.Writable() constructor super(options); } } //写法2: const Writable = require('stream').Writable; const myWritable = new Writable({ write(chunk, encoding, callback) { // ... }, writev(chunks, callback) { // ... } }); Writeable 与 Readable 的关系大致如下图: Image 1.5.1.2 - Writeable 与 Readable 的关系 3. Duplex & Transform Duplex & Transform 既是可读流也是可写流,类比水流管道中间部分,既有输入也有输出,输入输出分别都有各自的缓冲区。经常会有一种情况,就是输入和输出的速率不一样的情况,所以两端应该相对独立,可以为另一端调节速率。Transform 是一种特殊的 Duplex, Transform的输出以某种方式和输入相联系。Transform 内部流程图大致如下: Image 1.5.1.3 - Transform 内部工作流程图 gulp插件就是通过through2创建一个Transform,并执行一些操作然后返回创建的流。 参考资料 streamify-your-node-program node源码解析 -- Stream探究 Node.js Stream - 进阶篇 Node Stream stream-handbook 源码 var className='atoc'; © xdimh all right reserved，powered by Gitbook该文件修订时间： 2017-03-15 16:20:27 "},"mix/":{"url":"mix/","title":"大杂烩","keywords":"","body":"前端大杂烩 所谓大杂烩就是各种东西丢在一锅里乱炖,这里主要记录前端里面一些杂七杂八的东西,没地方放了就都丢在这一锅里吧。 var className='atoc'; © xdimh all right reserved，powered by Gitbook该文件修订时间： 2017-02-11 21:59:31 "},"mix/regular-expression.html":{"url":"mix/regular-expression.html","title":"JavaScript中的正则表达式之正向环视(正向断言)","keywords":"","body":"JavaScript中的正则表达式之正向环视(正向断言) 正则表达式在前端页面中很多地方有被应用到,特别是表单的验证逻辑部分,像验证邮箱,手机号,网址等,以及格式化字符串。比如最近遇到一个需求如下: 输入: 15210790946 输出: 152 1079 0946 对11位的手机号从最后面一位数字开始每4位数字前就需要加一个空格 要写好一个正则表达式最重要的首先是要清楚的知道组成每一个正则表达式部分的含义,元字符是正则表达式的重要组成部分。 元字符 元字符 名称 匹配对象 . 点号 单个任意字符 * 星号 之前紧邻的字符出现0+次 + 加号 之前紧邻的字符出现1+次 ? 问号 之前紧邻的字符出现0或者1次 [...] 字符组 列出的任意一个字符 [^...] 排除型字符组 除列出的字符外任意一个字符 (...) 分组符 括号内的分为一组 {n,m} 匹配次数限制 之前紧邻的字符出现至少n次至多m次 ^ 脱字符 行的起始位置 $ 美元符 行的末尾位置 | 竖线 匹配任意分隔的表达式 \\ 单词分界符 单词左边界 \\> or \\b 单词分界符 单词右边界 \\1,\\2 反向引用 分别存放匹配第一组括号,第二组括号文本内容 (?:...) 非捕获型分组 这个括号中匹配的内容不会被反向引用 \\w 缩写 等价于[A-Za-z0-9_] \\W 缩写 等价于[^A-Za-z0-9_] \\d 缩写 等价于[0-9] \\D 缩写 等价于[^0-9] \\s 缩写 匹配一个空白字符，包括空格、制表符、换页符和换行符。1 \\S 缩写 排除\\s 2 (?=...) 正向环视 匹配前面(右边)是...的位置 (? 逆向环视 匹配后面是...的位置 完成需求 // 对手机号码参数进行调整,去除手机号码中非数字字符,然后对手机号码应用格式化正则规则 // (?=(?:\\d{4})+$) 这个部分匹配以整数倍4个数字结尾的位置 // (\\d) 这里用来匹配一个数字,即只有以整数倍4个数字结尾的位置前面还有一个数字的情况下才需要添加空格。 // 因JavaScript 不支持逆向环视(逆向断言) 所以不能用replace(/(? 1. 等价于[\\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。 ↩ 2. 等价于[^ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。 ↩ var className='atoc'; © xdimh all right reserved，powered by Gitbook该文件修订时间： 2017-02-11 23:23:59 "},"mix/base64.html":{"url":"mix/base64.html","title":"base64的编码和解码","keywords":"","body":"base64的编码和解码 base64编码在各种编码中应该算是比较简单的一种了,在前端中很多地方有被应用到,小图片base64后内联,与客户端交互的jsBridge中数据的base64编码传输,小程序中字体图标base64后内联等等。这次在项目中用到了base64的编码和解码,网上搜了一把有很多base64操作的js实现,之前一直对base64编码半知半解,看着代码中的各种位操作也是云里雾里,所以借这次项目机会稍微深入的了解了下base64这个东西。 什么是base64编码? 对于base64 我们首先需要先看下ASCII编码,想必大家都知道在计算机内部所有的信息数据都表现为二进制的形式,就是那些0101数字串,每一个二进制位(bit)有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节(byte)。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从0000000到1111111。ASCII码就是用后7位二进制表示了128个字符,这对英语来说是够用了,所需要的字母都能在这后7位中表现出来。那么base64编码的规则又是什么,base64就是选出64个字符作为一个基本的字符集,然后在将其他文字符号都转换成这个字符集中的字符以予表示。这64个字符分别是a-z,A-Z ,0-9,符号+、-,除了前面几位还有=占位符,不属于所表示的内容。 字符base64编码的几个步骤 将待转换的字符串用二进制的形式表示出来。 然后每三个字节一组,也就是24个二进制位分成一组。 再将这24个二进制位分成6组,每四个一组,每组6位二进制位。 在每一组最前面添加两个00补全成八位,使得24位变成32位刚好凑成4个字节。 然后计算每个字节所表示的数值(10进制),根据下表查表拼装转换后的字符形成最后base64字符。 数值 符号 数值 符号 数值 符号 数值 符号 0 A 17 R 34 i 51 z 1 B 18 S 35 j 52 0 2 C 18 T 36 k 53 1 3 D 20 U 37 l 54 2 4 E 21 V 38 m 55 3 5 F 22 W 39 n 56 4 6 G 23 X 40 o 57 5 7 H 24 Y 41 p 58 6 8 I 25 Z 42 q 59 7 9 J 26 a 43 r 60 8 10 K 27 b 44 s 61 9 11 L 28 c 45 t 62 + 12 M 29 d 46 u 63 / 13 N 30 e 47 v 14 O 31 f 48 w 　　 15 P 32 g 49 x 16 Q 33 h 50 y 在转换的过程中可以发现,并不是所有的带转换字符串最后表示的二进制串所含的字节数都是3的倍数。所以针对这些不到3个字节的情况,会有相应的处理方式。 最后剩两个字节的情况 分成三组,前两组最前面加00组成两个字节,后面剩下的4位最前面加两个0,最后面加两个0,组成一个字节,最后补上一个=构成四个字节。 最后只剩一个字节的情况 分成两组,第一组6位最前面添加两位0,后面还剩2位,在最前面添加两个0,然后在最后面添加四个0构成两个字节,补上两个=,构成四个字节。(为什么前面要补两个00,这样计算二进制一个字节所表示的数值才能一一映射到64个字符中) Unicode Unicode（中文：万国码、国际码、统一码、单一码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。但并没有规定具体在计算机中的存储方式。Unicode的实现方式不同于编码方式。一个字符的Unicode编码是确定的。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式有所不同。Unicode的实现方式称为Unicode转换格式（Unicode Transformation Format，简称为UTF）。 UTF-8就是其中的一种实现方式。后面会讲Unicode的编码方式如何转换成UTF-8实现方式的。Unicode有17个code plane,其中0x0000 ~ 0xffff 称为基本多语言平面,0x10000 ~ 0x10ffff 16个为辅助平面。其中基本多语言平面已经涵盖了大部分常用字，如大部分的汉字,所以只需要对这个范围进行处理已经够用。参考Unicode字符平面映射 UTF-8 和 Unicode之间的转换关系 首先,UTF-8是一种针对Unicode的可变长度字符编码，也是一种前缀码。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个字节仍与ASCII兼容，这使得原来处理ASCII字符的软件无须或只须做少部分修改，即可继续使用。因此，它逐渐成为电子邮件、网页及其他存储或发送文字的应用中，优先采用的编码,是在互联网上使用最广的一种Unicode的实现方式。特点就是一种变长的编码方式,可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 128个US-ASCII字符只需一个字节编码（Unicode范围由U+0000至U+007F）。 带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要两个字节编码（Unicode范围由U+0080至U+07FF）。 其他基本多文种平面（BMP）中的字符（这包含了大部分常用字，如大部分的汉字）使用三个字节编码（Unicode范围由U+0800至U+FFFF）。 其他极少使用的Unicode 辅助平面的字符使用四字节编码 具体的转换对应关系如下表: code point UTF-8字节流 U+00000000 – U+0000007F 0xxxxxxx U+00000080 – U+000007FF 110xxxxx 10xxxxxx U+00000800 – U+0000FFFF 1110xxxx 10xxxxxx 10xxxxxx U+00010000 – U+001FFFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 由上表可见,转换后的字节数由第一个字节二进制串从左到右1的位数决定,0表示一个字节,110表示两个字节,1110对应三个字节,11110四个字节,后续字节都以10开始。根据这个规律我们就可以在代码实现上进行对Unicode和UTF-8之间进行转换。 JavaScript内部使用的编码方式 JavaScript 引擎内部是自由的使用 UCS-2 或者 UTF-16。大多数引擎使用的是 UTF-16，无论它们使用什么方式实现，它只是一个具体的实现，这不会影响到语言的特性。然后对于 ECMAScript/JavaScript 语言本身，实现的效果是通过 UCS-2，而非 UTF-16。参考:JavaScript 的内部字符编码是 UCS-2 还是 UTF-16 所以对于JavaScript,无论是UCS-2还是UTF-16都是一样,采用的是两个字节来存储字符。 ECMAScript source text is represented as a sequence of characters in the Unicode character encoding,version 3.0 or later. ... ... ECMAScript source text is assumed to be a sequence of 16-bit code units for the purposes of this specification. Such a source text may include sequences of 16-bit code units that are not valid UTF-16 character encodings. If an actual source text is encoded in a form other than 16-bit code units it must be processed as if it was first converted to UTF-16. 参考:ECMA-262 5.1 Edition 为了在加密解密中文字符不出现乱码,所以需要在将中文字符编码成base64之前,先将UCS-2/UTF-16 转换成 UTF-8 (这里只考虑中文字符是UTF-8的情况),然后再应用base64编码规则进行编码得到最终结果。同样在解码的时候需要按照base64编码规则反向操作转成UTF-8格式,然后再将UTF-8转回成UCS-2/UTF-16。 UTF-8 和 JavaScript 内部编码互相转换实现。 首先,了解JavaScript中几个方法String.charCodeAt,String.fromCharCode(),Number.prototype.toString。 String.charCodeAt charCodeAt() 方法返回0到65535之间的整数，表示给定索引处的UTF-16代码单元 (在 Unicode 编码单元表示一个单一的 UTF-16 编码单元的情况下，UTF-16 编码单元匹配 Unicode 编码单元。但在——例如 Unicode 编码单元 > 0x10000 的这种——不能被一个 UTF-16 编码单元单独表示的情况下，只能匹配 Unicode 代理对的第一个编码单元) 。如果你想要整个代码点的值，使用 codePointAt()。 '中'.charCodeAt(0); 20013 String.fromCharCode charCodeAt的反向操作 String.fromCharCode(20013); \"中\" Number.prototype.toString 将十进制码点转换成2进制。 var code = 20013; code.toString(2); \"100111000101101\" 互相转换源代码如下: UTF-16 -> UTF-8const Base64 = { ..., _utf8_encode: function(str) { // 将换行符统一成\\n str = str.replace(/\\r\\n/g, \"\\n\"); let out = \"\"; for (var n = 0; n = 0x0001) && (unicode 0x07ff) { //将16位unicode前四位和1110xxxx 进行拼接 out += String.fromCharCode(0xe0 | ((unicode >> 12) & 0x0f)); //将接下来的6位和10xxxxxx进行拼接 out += String.fromCharCode(0x80 | ((unicode >> 6) & 0x3f)); //将接下来的6位和10xxxxxx进行拼接 out += String.fromCharCode(0x80 | ((unicode >> 0) & 0x3f)); } else { //将16位unicode前5位和110xxxxx 进行拼接 out += String.fromCharCode(0xc0 | ((unicode >> 6) & 0x1f)); //将接下来的6位和10xxxxxx进行拼接 out += String.fromCharCode(0x80 | ((unicode >> 0) & 0x3f)); } } return out; }, ... } UTF8 -> UTF-16const Base64 = { ..., _utf8_decode: function(str) { let out = \"\",n = 0, c1,c2,c3; c1 = c2 = c3 = 0; while (n 0xc0 && c1 base64编码和解码的实现 base64编码 const Base64 = { ..., //base64 所用的64个字符和其中的一个补位符'=' _keyStr: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\", encode: function(str) { //base64转换算法就是根据具体的规则将3个字符变成四个字符。 let out = \"\",c1,c2,c3, outC1,outC2,outC3,outC4,i = 0; str = Base64._utf8_encode(str); //将utf16 转换成utf8,因为JavaScript内部采用的是utf16存储所以要进行一步转换。 while (i > 2; //第一个字符最前面添加两个0,剩余2位用作后面拼接 outC2 = (c1 & 0x03) > 4; // 第一个字符剩下两位和第二个字符前四位拼接,并在前面添加2个0拼成一个字符 outC3 = (c2 & 0x0f) > 6; //第二个字符剩余4位和第三个字符的前两位,并在前面添加2个0拼接成一个字符 outC4 = c3 & 0x3f; //第三个字符剩下的6位前面添加两个0 拼接成一个字符 //如果c2为不存在则最后两个字符为补位符'=' 如果c3不存在 则转换后最后一位为补位'=' if (isNaN(c2)) { outC3 = outC4 = 64 } else if (isNaN(c3)) { outC4 = 64 } out = out + this._keyStr.charAt(outC1) + this._keyStr.charAt(outC2) + this._keyStr.charAt(outC3) + this._keyStr.charAt(outC4) } return out }, ... } base64 解码const Base64 = { ..., decode: function(str) { let out = '',c1,c2,c3,c4,outC1,outC2,outC3,i = 0; //去掉非base64字符 str = str.replace(/[^A-Za-z0-9+/=]/g, \"\"); //循环处理进行解码 while (i > 4; //第一个base64字符去掉两个0后和第二个字符的开头两个字符拼成一个字节 outC2 = (c2 & 0x0f) > 2; //第二个剩下的4位和第三个开始的四位拼成一个字节 outC3 = (c3 & 0x03) Update: 2017-03-15 根据rfc3548,base64中的某些字符,在一些文件系统环境下或者url中会有特殊的含义,比如斜杠,所以为了得到web safe 的base64编码,则需要将第62个字符和第63个字符(编号从0开始)替换成 -(minus) 和 _(underscore) 减号和下划线。 可以对编码后的base64进行字符替换如下 : function urlSafeBase64Encode(input) { return input.replace('+', '-').replace('/', '_'); } 完整代码 参考资料 维基百科UTF-8 维基百科Unicode 字符编码笔记：ASCII，Unicode和UTF-8 —— 阮一峰 Base64笔记 —— 阮一峰 Unicode与JavaScript详解 —— 阮一峰 Unicode编码及其实现：UTF-16、UTF-8，and more 通过javascript进行UTF-8编码 按位操作符 var className='atoc'; © xdimh all right reserved，powered by Gitbook该文件修订时间： 2017-03-15 10:42:26 "},"mix/ngrok.html":{"url":"mix/ngrok.html","title":"使用ngrok让你的本地mock可以提供给外网访问","keywords":"","body":"使用ngrok让你的本地mock可以提供给外网访问 问题： 前端开发往往需要在本地启动mock服务提供模拟数据进行代码调试和自测。简单的mock已经足够满足本地代码调试和自测。然而开发过程中往往需要和其他端进行联调或者将代码作为demo给别人展示，例如：在开发完react-native页面，需要将页面嵌入到原生代码中，和native的同学对接，这个时候本地的mock接口往往是这样的接口地址http://localhost:9000/getData不能成功被请求，如果处于同一个内网这个时候可以通过写死接口ip地址来解决，如果不在同一个内网则（远程协作等情况）的时候，往往需要对接代码的人在本地也同样mock一份数据，过程较为复杂。 ngrok 介绍 ngrok 可以让本地地址穿透nat,firewall映射到能够在外网被访问的某个域名地址。这样本地请求可以改成使用这个统一的域名地址去请求，从而对接的时候不用手动去修改代码中的请求地址，提高了对接联调的效率。然后天下没有免费的午餐，自定义子域名这个功能只有付费的用户才能使用，但国内已经有人无私贡献了ngrok服务，造福于开发者，网站地址ngrok 国内 ngrok 安装使用 下载对对应平台的ngrok (eg: mac osx) 解压ngrok 官方版本只有一个ngrok可执行文件 ，国内版本有两个文件一个ngrok（后续需要手动添加可执行权限）和 ngrok.cfg 配置文件。国内重命名为ngrok2并添加可执行权限 mv ngrok ngrok2 && chmod u+x ngrok2 mv unzip-path/ngrok unzip-path/ngrok2 /usr/local/bin 或者 再path环境变量中添加解压后的目录路径。 使用 配置ngrok 配置文件 （国内版本不需要） authtoken: youtoken json_resolver_url: \"\" dns_resolver_ips: [] tunnels: dev: addr: 9000 auth: username:paswd proto: http # subdomain: xxxxx 付费用户才能用 token获取 启动本地mock [SUCCESS] 16:52:38 mock 服务启动成功: http://:::9000 启用ngrok 国内 : ngrok2 --config=ngrok.cfg -subdomain xxx 9000 官方: ngrok start --config=ngrok.yml --all 访问地址分别是: http://xxx.tunnel.qydev.com/getData 和 http://b79fb37b.ngrok.io/getData alias 命令 设置别名:在~/.bashrc 或者 ~/.bashprofile 中添加alias ngrok2=\"ngrok2 --config=/usr/local/opt/config/ngrok2.cfg\" 就可以直接使用ngrok2 -subdomain xxx 9000 启动服务 _ var className='atoc'; © xdimh all right reserved，powered by Gitbook该文件修订时间： 2017-03-20 15:07:33 "},"mix/gulp-plugin-develop.html":{"url":"mix/gulp-plugin-develop.html","title":"gulp插件开发","keywords":"","body":"gulp 插件开发 最近在做老代码的迁移,说实话真是蛋都要碎了。老代码用过的技术栈简直快包含整个前端的技术了,有dom操作库,kissy,zepto,现在盛行的MVVM框架vue,react,较早的模块管理requirejs,还有现在常用的打包工具gulp,webpack,这个项目简直就是一个前端技术的练兵场。不仅如此,源代码和线上代码不一致,代码仓库中并没有一份最新的代码。除此之外,打包配置文件写法真的是有点非主流,很多地方需要手动配置。其中用到的gulp插件数量也是没得说的,在梳理老代码构建打包任务时,有些地方并不是特别明白到底做了些什么,比如: return gulp.src(config[dist].views + '/*.*') .pipe(LinkRemove()) .pipe(gulp.dest(config[dist].views)); 其中LinkRemove,这个东西到底对源代码干了什么,作者并没有很清晰的给出,所以只能去看看这个gulp插件到底做了什么,却发现这个插件是作者自己写的,并没有上传到npm上,局面一度很尴尬,找到源代码,并没有很好的注释说明这是干什么的,可能作者觉得自己的代码即注释吧,虽然代码的确挺短的,但是我看到了这些: 'use strict'; var through = require('through2'), fs = require('fs'), trumpet = require(\"trumpet\"), concat = require(\"concat-stream\"); module.exports = function() { return through.obj(function(file, enc, cb) { //todo something }); } 局面再度尴尬起来,through2是什么,trumpet,concat-stream又是干嘛'屎'的。然后就涉及到了gulp插件的开发,如果不了解gulp插件的原理,是不可能搞懂那些没有注释文档的自己开发的插件功能的。gulp又是一个基于流的构建工具,打开插件编写文档,看到了这些关键词Buffer,Stream,vinyl File object,though,transform stream。如果你不了解这些那么也就不能很好的理解读懂别人写的插件源码或者编写自己的gulp插件。所以我们从Node Stream开始看起,毕竟gulp是基于流的一个工具。 Node Stream gulp是一个基于流的构建工具,将各个处理流链接起来达到前端构建的目的,使得前端构建能够实现自动化,自动的完成那些耗时费力又非常重要的构建任务,从而提高了整个开发的效率。那么什么是流呢,流又给gulp带来和别的构建工具哪些不一样呢? 对于什么是流参看Node Stream 初窥,相比之前流行的前端构建工具grunt来说: gulp可以使你将不同的任务通过流的方式链接起来,比如css预处理,css url中的链接修改, css合并压缩等任务,你只需在最开始输入要处理的文件,在最后输出的就是你需要的处理完成的文件。 每个任务,每个插件都是处理其中一部分处理,非常符合单一职责的原则。 其次gulp任务编写更加符合大家的习惯,和写正常的逻辑代码别无一二。 看完Stream,来来看看Buffer,毕竟很多插件是只处理Buffer数据的。 Node Buffer 在Node.js中Buffer是一个可以在任何模块中被利用的全局类,可以通过以下方式创建buffer对象。 通过构造函数指定buffer大小创建buffer对象 var buffer = new Buffer(size); 通过传入数组创建buffer对象 var buffer = new Buffer(array); // eg: var buffer = new Buffer([1,2,3]); 通过传入字符串创建Buffer对象 var buffer = new Buffer(string,[encoding]); //encoding 参数可选,默认编码方式为'utf8' Buffer对象可以通过toString方法转成字符串,toString方法有三个参数分别是encoding,start,end。buffer.toString([encoding],[start],[end])。 更多关于Buffer的内容可以参看node的文档,下面来看下在gulp中非常重要的一直virtual file format。 vinyl vinyl是一种虚拟文件的格式,用来描述一个文件的简单元数据对象, 对一个文件我们能想到的就是文件的路径和文件内容,这些都是vinyl 对象的主要的属性。那么这个和gulp有什么联系,其实gulp就是一个Vinyl Adapter,一个Vinyl Adapter需要提供src(globs) 和 dest(folder)方法,每个方法都返回对应的stream,src 返回的Stream 会产生Vinyl对象,用于后续使用,如gulp的插件。而dest会使用这些对象,并生成文件到指定的目录。 vinyl 对像方法 file.isBuffer() 判断文件内容是否是Buffer格式的,如果是返回true,反之返回false。 file.isStream() 判断文件内容是否是stream形式的,如果是返回true,反之返回false. file.isNull() 判断文件内容是否为空。如果是返回true,反之返回false. 更多的对象方法参看github上的文档。 vinyl 对象的属性 file.cwd 当前工作目录,最后的斜杠会被删除,通过file.cwd = newCwd 可以设置新的值。 file.base 文件基础目录。值应该等于path.dirname(file.path) file.path 文件的绝对路径。 file.relative 文件的相对路径,值等于path.resolve(file.base,file.path) 更多属性参看github上的文档。 vinyl-fs vinyl-fs 是 vinyl adapter, 具体使用可以参考github上的文档。一些gulp插件中会使用到这个vinyl adapter。 though2 though2 是Node streams.Transform 的一个简单的包装,更方便大家去创建transform流。 对于gulp插件总是会返回一个 object mode 形式的 tranform stream 来做这些事情。所以though2在插件中用的很频繁,简直就是标配。通过though2创建对象模式的transform方式如下: //method-1 : const though2 = require('though2'); though2({objectMode: true},function(chunk,enc,cb) { //todo something },[flushFunction]); //method-2 : though2.obj(function(chunk,enc,cb) { //todo something },[flushFunction]); 基于though2,有人写了though-gulp,使得编写gulp插件变得更加简单。 gulp 插件编写 gulp插件的基本代码架子如下: // PLUGIN_NAME: sample var through = require('through-gulp'); // exporting the plugin module.exports = sample; function sample() { // creating a stream through which each file will pass var stream = through(function(file, encoding,callback) { // do whatever necessary to process the file // 这里file为vinyl对象。 if (file.isNull()) { // 如果file的内容为空 } if (file.isBuffer()) { // 如果file的内容为Buffer } if (file.isStream()) { // 如果file的内容为stream } // just pipe data next, or just do nothing to process file later in flushFunction // never forget callback to indicate that the file has been processed. //确保文件进入下一个 gulp 插件 this.push(file); //告诉 stream 引擎，我们已经处理完了这个文件 callback(); //上面两行等价于 callback(null,file); }, function(callback) { // just pipe data next, just callback to indicate that the stream's over //由下一个gulp执行 this.push(something); callback(); //告诉 stream 引擎，我们已经处理完了 }); // returning the file stream return stream; }; 你需要做的是根据的自己的需求,编写相应的逻辑代码。我们可以看下一些插件的源码,这里以gulp-prefix举个例子,具体源码解读可以参看gulp-prefix插件源码阅读 gulp 插件测试 可以参看gulp 测试 在写测试之前,需要了解mocha 测试框架和chai 或者 shoud.js断言库。 var className='atoc'; © xdimh all right reserved，powered by Gitbook该文件修订时间： 2017-03-20 15:22:49 "},"source-code-read/gulp-prefix.html":{"url":"source-code-read/gulp-prefix.html","title":"gulp-prefix插件源码阅读","keywords":"","body":"gulp-prefix插件源码阅读 为什么会阅读这个插件的源码呢,因为在维护老项目的时候看到这个插件并没有给所有需要加前缀的url加上前缀,并因为ios需要支持https,而安卓客户端却不需要,为了能够自适应不同的客户端系统,则需要给url添加以双斜杠(//)开头的url,但是该插件却将双斜杠替换成了单斜杠,所以打算阅读下源代码看这个插件内部到底做了什么。 先列出gulp-prefix的源码如下: 'use strict'; var through = require('through2'), url = require(\"url\"), urljoin = require(\"url-join\"), trumpet = require(\"trumpet\"), concat = require(\"concat-stream\"), _prefixer; _prefixer = function(prefix, attr, invalid) { return function(node) { node.getAttribute(attr, function(uri) { uri = url.parse(uri, false, true); if(uri.host || !uri.path) return; if (!/^[!#$&-;=?-\\[\\]_a-z~\\.\\/\\{\\}]+$/.test(uri.path)) { return; } if (invalid && new RegExp(invalid).test(uri.path)){ return; } var file_prefix = (typeof prefix === 'function') ? prefix(uri) : prefix; node.setAttribute(attr, urljoin(file_prefix, uri.path)); }); }; }; module.exports = function(prefix, selectors, ignore) { return through.obj(function(file, enc, cb) { if (!selectors) { selectors = [ { match: \"script[src]\", attr: \"src\" }, { match: \"link[href]\", attr: \"href\"}, { match: \"img[src]\", attr: \"src\"}, { match: \"input[src]\", attr: \"src\"}, { match: \"img[data-ng-src]\", attr: \"data-ng-src\"} ]; } if(!prefix) cb(null, file); else { var tr = trumpet(); for (var a in selectors) tr.selectAll(selectors[a].match, _prefixer(prefix, selectors[a].attr, ignore)) tr.pipe(concat(function (data) { if (Array.isArray(data) && data.length === 0) data = null; file.contents = data; cb(null, file); })); file.pipe(tr); } }); }; 代码的开头是依赖模块的引入和一些变量的定义,这个插件主要依赖了url,though2,url-join,trumpet,concat-stream等模块。 url 模块 url模块是node内置模块,用来对url进行解析处理并生成由url各个部分组成的解析结果对象。 though2 用来生成transform stream。 具体stream的一些概念参看Node Stream初窥,though2的具体使用参看文档。 url-join 作用将url的各个部分链接起来,形成合法的url。 trumpet 使用css 选择器解析处理stream 形式的html。 //使用方法 var trumpet = require('trumpet'); //Create a new trumpet stream. This stream is readable and writable. Pipe an html stream into tr and get back a transformed html stream. var tr = trumpet(); //将html 可读流和tr链接 var fs = require('fs'); fs.createReadStream(__dirname + '/html/read_all.html').pipe(tr); //将产生的transformed html stream,选择其中满足css selector,创建一个可读流链接到输出流 //这里如果span.createReadStream() 不加任何参数的话,默认取得是标签内的内容,不带标签,如果要获取到完整的html片段,则需要调用时增加选项参数{outer:true} tr.selectAll('.b span', function (span) { span.createReadStream().pipe(process.stdout); }); concat-stream 从名字可以猜这个模块应该是用来连接什么的,文档介绍说如果你有将stream中的所有buffer连接成一个buffer,然后再进行处理的需求的话,那么这个模块就是你想要的,由于stream的特性,导致每次得到的数据只是一个chunk buffer,所以有时你需要得到全部的数据你才能进行某些操作,那么就可以通过这个模块到达想要的结果。 //使用例子 var fs = require('fs') var concat = require('concat-stream') function gotPicture(imageBuffer) { // imageBuffer is all of `cat.png` as a node.js Buffer } function handleError(err) { // handle your error appropriately here, e.g.: console.error(err) // print the error to STDERR process.exit(1) // exit program with non-zero exit code } var readStream = fs.createReadStream('cat.png') var concatStream = concat(gotPicture) readStream.on('error', handleError) readStream.pipe(concatStream) 在了解了上面gulp-prefix所依赖的插件后,我们就可以开始看这个插件到底做了什么事情了。首先看module.exports,导出一个函数这个函数可以接受三个参数: prefix 字符串或者用于生成url前缀的函数。 selectors 对象数组,需要被替换的html标签,以及标签属性。具体格式如下: [ { match: \"script[src]\", attr: \"src\" }, { match: \"link[href]\", attr: \"href\"}, { match: \"img[src]\", attr: \"src\"}, { match: \"input[src]\", attr: \"src\"}, { match: \"img[data-ng-src]\", attr: \"data-ng-src\"} ] ignore 要被过滤的路径,new Regex(ignore).test(path) 为true的话,则不进行添加前缀操作。 再来看这段代码: if(!prefix) cb(null, file); else { var tr = trumpet(); for (var a in selectors) tr.selectAll(selectors[a].match, _prefixer(prefix, selectors[a].attr, ignore)) tr.pipe(concat(function (data) { if (Array.isArray(data) && data.length === 0) data = null; file.contents = data; cb(null, file); })); file.pipe(tr); } 对prefix进行判断,如果为空,则将file交给下一个插件进行处理,如果不为空,则进行如下处理,创建tr,用于和file链接,遍历selectors,然后选择匹配选择器的元素交由_prefixer的方法进行处理,这个方法会返回一个回调函数,这个回调函数的参数node就是匹配选择器的元素。然后在将tr处理后的file流向concat创建的流,当整个文件处理完,调用传入concat的回调,然后设置file内容为处理后的内容,流向下个插件。 其中_prefixer,是真正修改url的地方,我们看下代码内容: function(prefix, attr, invalid) { return function(node) { node.getAttribute(attr, function(uri) { uri = url.parse(uri, false, true); if(uri.host || !uri.path) return; if (!/^[!#$&-;=?-\\[\\]_a-z~\\.\\/\\{\\}]+$/.test(uri.path)) { return; } if (invalid && new RegExp(invalid).test(uri.path)){ return; } var file_prefix = (typeof prefix === 'function') ? prefix(uri) : prefix; node.setAttribute(attr, urljoin(file_prefix, uri.path)); }); }; }; 从代码中看出返回的回调函数,从node中取出attr属性值(url路径),然后通过url模块进行解析,url.parse的参数含义参考文档url.parse,最后一个参数设置为true,考虑了路径为双斜杠开头的情况,那么后面// 到 /之间的值就是host了。如果存在host或者path不存在,则认为这种情况不需要添加前缀了。如果是合法path则接下去进行处理,如果path匹配ignore(invalid),则不处理,最后进行前缀添加,如果prefix是函数,执行函数并返回file_prefix文件前缀。然后通过url-join模块合并前缀和path,重新设置node(节点)的属性值。 当读到这里的时候,发现img标签中的data-lazyload-src没有被加前缀的原因是默认的selectors中没有对应的selector,添加后修复了这个问题。但是双斜杠的问题还是存在,从整个代码来看,最可能出问题的地方就是urljoin这里了,后来看了url-join模块的源码,才发现gulp-prefix用的是很早的版本,从package.json中可以看出: \"dependencies\": { \"through2\": \"~1.0.0\", \"url\": \"~0.10.1\", \"trumpet\": \"~1.7.0\", \"concat-stream\": \"~1.4.5\", \"url-join\": \"0.0.1\" //这里版本为0.0.1,现在已经是v1.1.0 } 0.0.1版本的url-join源代码如下: function normalize (str) { return str .replace(/[\\/]+/g, '/') .replace(/\\/\\?/g, '?') .replace(/\\/\\#/g, '#') .replace(/\\:\\//g, '://'); } module.exports = function () { var joined = [].slice.call(arguments, 0).join('/'); return normalize(joined); }; 很明显这个地方将双斜杠给替换成了单斜杠,给作者提了pull request,作者并没有鸟,尝试自己升级了url-join最后解决了双斜杠被删成单斜杠的问题。 gulp-prefix 可以改进的地方 selectors 参数格式,数组的话作者并没有增量合并,而是需要自己枚举所有情况。 url-join 在package.json中写死了版本,导致双斜杠变单斜杠的问题。 查了一波MIT证书的限制,对于MIT证书来说,只要用户在项目副本中包含了版权声明和许可声明,你可以拿这个代码做任何事情。所以决定对代码略作修改使其更好的用在自己的平常构建任务中。改造后重命名为gulp-prefix-url,并写了测试用例进行测试。插件的GitHub地址为:https://github.com/xdimh/gulp-prefix-url。 参考 各种 License choosealicense var className='atoc'; © xdimh all right reserved，powered by Gitbook该文件修订时间： 2017-03-20 15:15:16 "}}