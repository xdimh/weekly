{"./":{"url":"./","title":"前言","keywords":"","body":"关于本书 前端是一个技术更新发展比较快的行业,需要你不停的去学习,更新完善自己的技术栈,俗话说,好记性不如烂笔头,打算把自己做项目过程中的一些心得,遇到过并填过的坑,同时将自己学习的新知识,平常摸过的鱼记录在此,以便以后如果遇到类似的问题,类似的坑,需要用到之前看过的技术的时候有个地方可以参考。 不管做什么贵在坚持,希望自己能够坚持做好记录这件事。 var className='atoc'; © xdimh all right reserved，powered by Gitbook该文件修订时间： 2017-02-11 20:16:12 "},"react/":{"url":"react/","title":"React 开发汇总","keywords":"","body":"var className='atoc'; © xdimh all right reserved，powered by Gitbook该文件修订时间： 2017-02-11 21:54:33 "},"react-native/":{"url":"react-native/","title":"React Native 开发汇总 ","keywords":"","body":"var className='atoc'; © xdimh all right reserved，powered by Gitbook该文件修订时间： 2017-02-08 14:48:57 "},"react-native/rn-dev-prepare.html":{"url":"react-native/rn-dev-prepare.html","title":"Mac上搭建RN开发环境","keywords":"","body":"Mac上搭建RN开发环境 安装依赖 在针对特定平台开发环境建立之前,你需要先安装node,watchman,react-native-cli。在Mac上我们可以通过HomeBrew进行相应的安装。 brew install node brew install watchman brew install flow npm install -g react-native-cli ios 开发环境搭建 对于ios 只需要从app store中安装xcode即可,安装xcode会自动安装ios 模拟器以及一些构建app所需要的工具。通过react-native 命令初始化一个项目然后测试ios开发环境是否成功建立。 react-native init AwesomeProject cd AwesomeProject 在ios模拟器中启动应用,两种方式: 通过命令行直接唤起模拟器打开app react-native run-ios 执行完该命令,正常情况下,会打开ios模拟器,然后启动应用以供调试。 进入目录AwesomeProject,打开ios目录下的文件AwesomeProject.xcodeproj,如果xcode成功安装,默认会打开xcode。然后直接 android 开发环境搭建 对于android开发环境要稍微复杂一些。 安装安卓模拟器genymotion 安装完成后需要去官网注册一个账户并激活,后续创建虚拟设备将会用到。 安装virtual box 安装最新版JDK 安装安卓Android Studio 打开sdk manager 安装的Android sdk Image 1.3.1.1 - android studio 选择需要安装的内容 Image 1.3.1.2 - android sdk 打开genymotion 创建安卓模拟器 先设置好正确的android sdk路径 添加相应的虚拟设备 打开对应的虚拟设备测试安卓开发环境是否成功建立 打开对于的虚拟设备后,在项目根目录执行命令启动应用: react-native run-android 这一步可能发送报错java.io.EOFException: SSL peer shut down incorrectly,解决方案在后面。 这个时候如果build successfully 则在模拟器上可以看到对于app的页面,如果模拟器上出现如下报错: 需要设置对应的debug host为当前电脑的ip地址,如下图: 环境配置过程报错解决 对于安卓开发环境步骤6中运行react-native run-android所报错误解决方法 下载gradle-2.4-all.zip到本地 本地启动对于的服务 修改android/gradle/wrapper下gradle-wrapper.properties文件中的distributionUrl为本地地址,重新执行react-native run-android 参考资料 React Native Android（Genymotion） 环境搭建 for mac 学习 React Native for Android：环境搭建 Getting Started with Building An App with React Native, Genymotion, and Watchman react native getting started react-native run-android 报错解决 React Native For Android初体验 var className='atoc'; © xdimh all right reserved，powered by Gitbook该文件修订时间： 2017-02-14 13:59:35 "},"electron/":{"url":"electron/","title":"Electron 开发汇总","keywords":"","body":"var className='atoc'; © xdimh all right reserved，powered by Gitbook该文件修订时间： 2017-02-08 14:48:57 "},"mix/":{"url":"mix/","title":"大杂烩","keywords":"","body":"前端大杂烩 所谓大杂烩就是各种东西丢在一锅里乱炖,这里主要记录前端里面一些杂七杂八的东西,没地方放了就都丢在这一锅里吧。 var className='atoc'; © xdimh all right reserved，powered by Gitbook该文件修订时间： 2017-02-11 21:59:31 "},"mix/regular-expression.html":{"url":"mix/regular-expression.html","title":"JavaScript中的正则表达式之正向环视(正向断言)","keywords":"","body":"JavaScript中的正则表达式之正向环视(正向断言) 正则表达式在前端页面中很多地方有被应用到,特别是表单的验证逻辑部分,像验证邮箱,手机号,网址等,以及格式化字符串。比如最近遇到一个需求如下: 输入: 15210790946 输出: 152 1079 0946 对11位的手机号从最后面一位数字开始每4位数字前就需要加一个空格 要写好一个正则表达式最重要的首先是要清楚的知道组成每一个正则表达式部分的含义,元字符是正则表达式的重要组成部分。 元字符 元字符 名称 匹配对象 . 点号 单个任意字符 * 星号 之前紧邻的字符出现0+次 + 加号 之前紧邻的字符出现1+次 ? 问号 之前紧邻的字符出现0或者1次 [...] 字符组 列出的任意一个字符 [^...] 排除型字符组 除列出的字符外任意一个字符 (...) 分组符 括号内的分为一组 {n,m} 匹配次数限制 之前紧邻的字符出现至少n次至多m次 ^ 脱字符 行的起始位置 $ 美元符 行的末尾位置 | 竖线 匹配任意分隔的表达式 \\ 单词分界符 单词左边界 \\> or \\b 单词分界符 单词右边界 \\1,\\2 反向引用 分别存放匹配第一组括号,第二组括号文本内容 (?:...) 非捕获型分组 这个括号中匹配的内容不会被反向引用 \\w 缩写 等价于[A-Za-z0-9_] \\W 缩写 等价于[^A-Za-z0-9_] \\d 缩写 等价于[0-9] \\D 缩写 等价于[^0-9] \\s 缩写 匹配一个空白字符，包括空格、制表符、换页符和换行符。1 \\S 缩写 排除\\s 2 (?=...) 正向环视 匹配前面(右边)是...的位置 (? 逆向环视 匹配后面是...的位置 完成需求 // 对手机号码参数进行调整,去除手机号码中非数字字符,然后对手机号码应用格式化正则规则 // (?=(?:\\d{4})+$) 这个部分匹配以整数倍4个数字结尾的位置 // (\\d) 这里用来匹配一个数字,即只有以整数倍4个数字结尾的位置前面还有一个数字的情况下才需要添加空格。 // 因JavaScript 不支持逆向环视(逆向断言) 所以不能用replace(/(? 1. 等价于[\\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。 ↩ 2. 等价于[^ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。 ↩ var className='atoc'; © xdimh all right reserved，powered by Gitbook该文件修订时间： 2017-02-11 23:23:59 "},"mix/base64.html":{"url":"mix/base64.html","title":"base64的编码和解码","keywords":"","body":"base64的编码和解码 base64编码在各种编码中应该算是比较简单的一种了,在前端中很多地方有被应用到,小图片base64后内联,与客户端交互的jsBridge中数据的base64编码传输,小程序中字体图标base64后内联等等。这次在项目中用到了base64的编码和解码,网上搜了一把有很多base64操作的js实现,之前一直对base64编码半知半解,看着代码中的各种位操作也是云里雾里,所以借这次项目机会稍微深入的了解了下base64这个东西。 什么是base64编码? 对于base64 我们首先需要先看下ASCII编码,想必大家都知道在计算机内部所有的信息数据都表现为二进制的形式,就是那些0101数字串,每一个二进制位(bit)有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节(byte)。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从0000000到1111111。ASCII码就是用后7位二进制表示了128个字符,这对英语来说是够用了,所需要的字母都能在这后7位中表现出来。那么base64编码的规则又是什么,base64就是选出64个字符作为一个基本的字符集,然后在将其他文字符号都转换成这个字符集中的字符以予表示。这64个字符分别是a-z,A-Z ,0-9,符号+、-,除了前面几位还有=占位符,不属于所表示的内容。 字符base64编码的几个步骤 将待转换的字符串用二进制的形式表示出来。 然后每三个字节一组,也就是24个二进制位分成一组。 再将这24个二进制位分成6组,每四个一组,每组6位二进制位。 在每一组最前面添加两个00补全成八位,使得24位变成32位刚好凑成4个字节。 然后计算每个字节所表示的数值(10进制),根据下表查表拼装转换后的字符形成最后base64字符。 数值 符号 数值 符号 数值 符号 数值 符号 0 A 17 R 34 i 51 z 1 B 18 S 35 j 52 0 2 C 18 T 36 k 53 1 3 D 20 U 37 l 54 2 4 E 21 V 38 m 55 3 5 F 22 W 39 n 56 4 6 G 23 X 40 o 57 5 7 H 24 Y 41 p 58 6 8 I 25 Z 42 q 59 7 9 J 26 a 43 r 60 8 10 K 27 b 44 s 61 9 11 L 28 c 45 t 62 + 12 M 29 d 46 u 63 / 13 N 30 e 47 v 14 O 31 f 48 w 　　 15 P 32 g 49 x 16 Q 33 h 50 y 在转换的过程中可以发现,并不是所有的带转换字符串最后表示的二进制串所含的字节数都是3的倍数。所以针对这些不到3个字节的情况,会有相应的处理方式。 最后剩两个字节的情况 分成三组,前两组最前面加00组成两个字节,后面剩下的4位最前面加两个0,最后面加两个0,组成一个字节,最后补上一个=构成四个字节。 最后只剩一个字节的情况 分成两组,第一组6位最前面添加两位0,后面还剩2位,在最前面添加两个0,然后在最后面添加四个0构成两个字节,补上两个=,构成四个字节。(为什么前面要补两个00,这样计算二进制一个字节所表示的数值才能一一映射到64个字符中) Unicode Unicode（中文：万国码、国际码、统一码、单一码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。但并没有规定具体在计算机中的存储方式。Unicode的实现方式不同于编码方式。一个字符的Unicode编码是确定的。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式有所不同。Unicode的实现方式称为Unicode转换格式（Unicode Transformation Format，简称为UTF）。 UTF-8就是其中的一种实现方式。后面会讲Unicode的编码方式如何转换成UTF-8实现方式的。Unicode有17个code plane,其中0x0000 ~ 0xffff 称为基本多语言平面,0x10000 ~ 0x10ffff 16个为辅助平面。其中基本多语言平面已经涵盖了大部分常用字，如大部分的汉字,所以只需要对这个范围进行处理已经够用。参考Unicode字符平面映射 UTF-8 和 Unicode之间的转换关系 首先,UTF-8是一种针对Unicode的可变长度字符编码，也是一种前缀码。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个字节仍与ASCII兼容，这使得原来处理ASCII字符的软件无须或只须做少部分修改，即可继续使用。因此，它逐渐成为电子邮件、网页及其他存储或发送文字的应用中，优先采用的编码,是在互联网上使用最广的一种Unicode的实现方式。特点就是一种变长的编码方式,可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。 128个US-ASCII字符只需一个字节编码（Unicode范围由U+0000至U+007F）。 带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要两个字节编码（Unicode范围由U+0080至U+07FF）。 其他基本多文种平面（BMP）中的字符（这包含了大部分常用字，如大部分的汉字）使用三个字节编码（Unicode范围由U+0800至U+FFFF）。 其他极少使用的Unicode 辅助平面的字符使用四字节编码 具体的转换对应关系如下表: code point UTF-8字节流 U+00000000 – U+0000007F 0xxxxxxx U+00000080 – U+000007FF 110xxxxx 10xxxxxx U+00000800 – U+0000FFFF 1110xxxx 10xxxxxx 10xxxxxx U+00010000 – U+001FFFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 由上表可见,转换后的字节数由第一个字节二进制串从左到右1的位数决定,0表示一个字节,110表示两个字节,1110对应三个字节,11110四个字节,后续字节都以10开始。根据这个规律我们就可以在代码实现上进行对Unicode和UTF-8之间进行转换。 JavaScript内部使用的编码方式 JavaScript 引擎内部是自由的使用 UCS-2 或者 UTF-16。大多数引擎使用的是 UTF-16，无论它们使用什么方式实现，它只是一个具体的实现，这不会影响到语言的特性。然后对于 ECMAScript/JavaScript 语言本身，实现的效果是通过 UCS-2，而非 UTF-16。参考:JavaScript 的内部字符编码是 UCS-2 还是 UTF-16 所以对于JavaScript,无论是UCS-2还是UTF-16都是一样,采用的是两个字节来存储字符。 ECMAScript source text is represented as a sequence of characters in the Unicode character encoding,version 3.0 or later. ... ... ECMAScript source text is assumed to be a sequence of 16-bit code units for the purposes of this specification. Such a source text may include sequences of 16-bit code units that are not valid UTF-16 character encodings. If an actual source text is encoded in a form other than 16-bit code units it must be processed as if it was first converted to UTF-16. 参考:ECMA-262 5.1 Edition 为了在加密解密中文字符不出现乱码,所以需要在将中文字符编码成base64之前,先将UCS-2/UTF-16 转换成 UTF-8 (这里只考虑中文字符是UTF-8的情况),然后再应用base64编码规则进行编码得到最终结果。同样在解码的时候需要按照base64编码规则反向操作转成UTF-8格式,然后再将UTF-8转回成UCS-2/UTF-16。 UTF-8 和 JavaScript 内部编码互相转换实现。 首先,了解JavaScript中几个方法String.charCodeAt,String.fromCharCode(),Number.prototype.toString。 String.charCodeAt charCodeAt() 方法返回0到65535之间的整数，表示给定索引处的UTF-16代码单元 (在 Unicode 编码单元表示一个单一的 UTF-16 编码单元的情况下，UTF-16 编码单元匹配 Unicode 编码单元。但在——例如 Unicode 编码单元 > 0x10000 的这种——不能被一个 UTF-16 编码单元单独表示的情况下，只能匹配 Unicode 代理对的第一个编码单元) 。如果你想要整个代码点的值，使用 codePointAt()。 '中'.charCodeAt(0); 20013 String.fromCharCode charCodeAt的反向操作 String.fromCharCode(20013); \"中\" Number.prototype.toString 将十进制码点转换成2进制。 var code = 20013; code.toString(2); \"100111000101101\" 互相转换源代码如下: UTF-16 -> UTF-8const Base64 = { ..., _utf8_encode: function(str) { // 将换行符统一成\\n str = str.replace(/\\r\\n/g, \"\\n\"); let out = \"\"; for (var n = 0; n = 0x0001) && (unicode 0x07ff) { //将16位unicode前四位和1110xxxx 进行拼接 out += String.fromCharCode(0xe0 | ((unicode >> 12) & 0x0f)); //将接下来的6位和10xxxxxx进行拼接 out += String.fromCharCode(0x80 | ((unicode >> 6) & 0x3f)); //将接下来的6位和10xxxxxx进行拼接 out += String.fromCharCode(0x80 | ((unicode >> 0) & 0x3f)); } else { //将16位unicode前5位和110xxxxx 进行拼接 out += String.fromCharCode(0xc0 | ((unicode >> 6) & 0x1f)); //将接下来的6位和10xxxxxx进行拼接 out += String.fromCharCode(0x80 | ((unicode >> 0) & 0x3f)); } } return out; }, ... } UTF8 -> UTF-16const Base64 = { ..., _utf8_decode: function(str) { let out = \"\",n = 0, c1,c2,c3; c1 = c2 = c3 = 0; while (n 0xc0 && c1 base64编码和解码的实现 base64编码 const Base64 = { ..., //base64 所用的64个字符和其中的一个补位符'=' _keyStr: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\", encode: function(str) { //base64转换算法就是根据具体的规则将3个字符变成四个字符。 let out = \"\",c1,c2,c3, outC1,outC2,outC3,outC4,i = 0; str = Base64._utf8_encode(str); //将utf16 转换成utf8,因为JavaScript内部采用的是utf16存储所以要进行一步转换。 while (i > 2; //第一个字符最前面添加两个0,剩余2位用作后面拼接 outC2 = (c1 & 0x03) > 4; // 第一个字符剩下两位和第二个字符前四位拼接,并在前面添加2个0拼成一个字符 outC3 = (c2 & 0x0f) > 6; //第二个字符剩余4位和第三个字符的前两位,并在前面添加2个0拼接成一个字符 outC4 = c3 & 0x3f; //第三个字符剩下的6位前面添加两个0 拼接成一个字符 //如果c2为不存在则最后两个字符为补位符'=' 如果c3不存在 则转换后最后一位为补位'=' if (isNaN(c2)) { outC3 = outC4 = 64 } else if (isNaN(c3)) { outC4 = 64 } out = out + this._keyStr.charAt(outC1) + this._keyStr.charAt(outC2) + this._keyStr.charAt(outC3) + this._keyStr.charAt(outC4) } return out }, ... } base64 解码const Base64 = { ..., decode: function(str) { let out = '',c1,c2,c3,c4,outC1,outC2,outC3,i = 0; //去掉非base64字符 str = str.replace(/[^A-Za-z0-9+/=]/g, \"\"); //循环处理进行解码 while (i > 4; //第一个base64字符去掉两个0后和第二个字符的开头两个字符拼成一个字节 outC2 = (c2 & 0x0f) > 2; //第二个剩下的4位和第三个开始的四位拼成一个字节 outC3 = (c3 & 0x03) 完整代码 参考资料 维基百科UTF-8 维基百科Unicode 字符编码笔记：ASCII，Unicode和UTF-8 —— 阮一峰 Base64笔记 —— 阮一峰 Unicode与JavaScript详解 —— 阮一峰 Unicode编码及其实现：UTF-16、UTF-8，and more 通过javascript进行UTF-8编码 var className='atoc'; © xdimh all right reserved，powered by Gitbook该文件修订时间： 2017-02-21 17:17:41 "},"mix/ngrok.html":{"url":"mix/ngrok.html","title":"使用ngrok让你的本地mock可以提供给外网访问","keywords":"","body":"使用ngrok让你的本地mock可以提供给外网访问 问题： 前端开发往往需要在本地启动mock服务提供模拟数据进行代码调试和自测。简单的mock已经足够满足本地代码调试和自测。然而开发过程中往往需要和其他端进行联调或者将代码作为demo给别人展示，例如：在开发完react-native页面，需要将页面嵌入到原生代码中，和native的同学对接，这个时候本地的mock接口往往是这样的接口地址http://localhost:9000/getData不能成功被请求，如果处于同一个内网这个时候可以通过写死接口ip地址来解决，如果不在同一个内网则（远程协作等情况）的时候，往往需要对接代码的人在本地也同样mock一份数据，过程较为复杂。 ngrok 介绍 ngrok 可以让本地地址穿透nat,firewall映射到能够在外网被访问的某个域名地址。这样本地请求可以改成使用这个统一的域名地址去请求，从而对接的时候不用手动去修改代码中的请求地址，提高了对接联调的效率。然后天下没有免费的午餐，自定义子域名这个功能只有付费的用户才能使用，但国内已经有人无私贡献了ngrok服务，造福于开发者，网站地址ngrok 国内 ngrok 安装使用 下载对对应平台的ngrok (eg: mac osx) 解压ngrok 官方版本只有一个ngrok可执行文件 ，国内版本有两个文件一个ngrok（后续需要手动添加可执行权限）和 ngrok.cfg 配置文件。国内重命名为ngrok2并添加可执行权限 mv ngrok ngrok2 && chmod u+x ngrok2 mv unzip-path/ngrok unzip-path/ngrok2 /usr/local/bin 或者 再path环境变量中添加解压后的目录路径。 使用 配置ngrok 配置文件 （国内版本不需要） authtoken: youtoken json_resolver_url: \"\" dns_resolver_ips: [] tunnels: dev: addr: 9000 auth: username:paswd proto: http # subdomain: xxxxx 付费用户才能用 token获取 启动本地mock [SUCCESS] 16:52:38 mock 服务启动成功: http://:::9000 启用ngrok 国内 : ngrok2 --config=ngrok.cfg -subdomain xxx 9000 官方: ngrok start --config=ngrok.yml --all 访问地址分别是: http://xxx.tunnel.qydev.com/getData 和 http://b79fb37b.ngrok.io/getData alias 命令 设置别名:在~/.bashrc 或者 ~/.bashprofile 中添加alias ngrok2=\"ngrok2 --config=/usr/local/opt/config/ngrok2.cfg\" 就可以直接使用ngrok2 -subdomain xxx 9000 启动服务 _ var className='atoc'; © xdimh all right reserved，powered by Gitbook该文件修订时间： 2017-02-21 17:22:39 "}}